<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>io_helpers.c - SORTENY Encoder</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <style>
        :root {
            --bg: #f6f8fa;
            --border: #d0d7de;
            --text: #24292f;
            --header-bg: #2c3e50;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.5;
        }
        .header {
            background: var(--header-bg);
            color: white;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header h1 { font-size: 1.25rem; font-weight: 600; }
        .header a { color: #58a6ff; text-decoration: none; }
        .header a:hover { text-decoration: underline; }
        .file-info {
            background: white;
            border-bottom: 1px solid var(--border);
            padding: 0.75rem 2rem;
            font-size: 0.875rem;
            color: #57606a;
        }
        .code-container {
            background: white;
            border: 1px solid var(--border);
            border-radius: 6px;
            margin: 1rem 2rem;
            overflow: hidden;
        }
        pre {
            margin: 0;
            padding: 1rem;
            overflow-x: auto;
            font-size: 0.875rem;
            line-height: 1.45;
        }
        code {
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        .hljs { background: white !important; }
    </style>
</head>
<body>
    <div class="header">
        <h1>üìÑ io_helpers.c</h1>
        <a href="../../../index.html">‚Üê Tornar a l'√≠ndex</a>
    </div>
    <div class="file-info">
        <strong>Ruta:</strong> src/c/io_helpers.c &nbsp;|&nbsp;
        <strong>Descripci√≥:</strong> Funcions d'entrada/sortida per a la c√†rrega d'imatges RAW (BSQ, uint16) i escriptura de tensors.
    </div>
    <div class="code-container">
        <pre><code class="language-c">// IO helpers: lectura/escritura de tensores e imagen RAW (BSQ)
#include "io_helpers.h"
#include &lt;sys/stat.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

/**
 * @brief Comprueba si la m√°quina es little-endian.
 */
static int is_machine_little_endian(void) {
    uint16_t x = 1;
    return *((uint8_t*)&amp;x) == 1;
}

/**
 * @brief Intercambia el orden de bytes de un uint16_t.
 */
static uint16_t bswap16(uint16_t v) {
    return (uint16_t)((v &gt;&gt; 8) | (v &lt;&lt; 8));
}

/**
 * @brief Carga una imagen RAW (BSQ, uint16) y la convierte a float planar (B x H x W).
 * Variante extendida con validaciones y opciones.
 * @param filename Ruta al archivo .raw
 * @param B Bandas
 * @param H Altura
 * @param W Anchura
 * @param expect_little_endian 1: archivo little-endian; 0: big-endian; -1: no forzar
 * @param scale_to_unit 1 para normalizar a [0,1] dividiendo por 65535, 0 deja valores originales
 * @return Puntero (malloc) al tensor de floats o NULL si falla.
 */
float* load_image_bsq_u16_to_planar_f32_ex(const char* filename, int B, int H, int W,
                                           int expect_little_endian, int scale_to_unit) {
    if (B &lt;= 0 || H &lt;= 0 || W &lt;= 0) {
        fprintf(stderr, "Error [IO]: Dimensiones inv√°lidas B,H,W.\n");
        return NULL;
    }

    // Prevenir overflow
    size_t sB = (size_t)B, sH = (size_t)H, sW = (size_t)W;
    if (sB &gt; SIZE_MAX / sH || (sB * sH) &gt; SIZE_MAX / sW) {
        fprintf(stderr, "Error [IO]: Overflow calculando total de elementos.\n");
        return NULL;
    }
    size_t total_elements = sB * sH * sW;

    // Validar tama√±o de archivo
    struct stat st;
    if (stat(filename, &amp;st) != 0) {
        fprintf(stderr, "Error [IO]: stat() fall√≥ para %s: %s\n", filename, strerror(errno));
        return NULL;
    }
    size_t expected_bytes = total_elements * sizeof(uint16_t);
    if ((size_t)st.st_size != expected_bytes) {
        fprintf(stderr, "Error [IO]: Tama√±o inesperado. Esperado %zu bytes, real %lld bytes.\n",
                expected_bytes, (long long)st.st_size);
        return NULL;
    }

    FILE* f = fopen(filename, "rb");
    if (!f) {
        fprintf(stderr, "Error [IO]: No se pudo abrir la imagen de entrada: %s\n", filename);
        return NULL;
    }

    uint16_t* bsq_buffer = (uint16_t*)malloc(expected_bytes);
    if (!bsq_buffer) {
        fprintf(stderr, "Error [IO]: Fallo de Malloc para bsq_buffer (%zu bytes)\n", expected_bytes);
        fclose(f);
        return NULL;
    }

    size_t read_count = fread(bsq_buffer, sizeof(uint16_t), total_elements, f);
    fclose(f);
    if (read_count != total_elements) {
        fprintf(stderr, "Error [IO]: Lectura incompleta de la imagen: %s (%zu/%zu)\n",
                filename, read_count, total_elements);
        free(bsq_buffer);
        return NULL;
    }

    // Endianness: decidir si swap
    int do_swap = 0;
    if (expect_little_endian == 0 || expect_little_endian == 1) {
        int mach_le = is_machine_little_endian();
        int file_le = expect_little_endian;
        do_swap = (mach_le != file_le);
    }

    float scale = scale_to_unit ? (1.0f / 65535.0f) : 1.0f;
    float* planar_tensor = (float*)malloc(total_elements * sizeof(float));
    if (!planar_tensor) {
        fprintf(stderr, "Error [IO]: Fallo de Malloc para planar_tensor\n");
        free(bsq_buffer);
        return NULL;
    }

    if (do_swap) {
        for (size_t i = 0; i &lt; total_elements; i++) {
            uint16_t v = bswap16(bsq_buffer[i]);
            planar_tensor[i] = (float)v * scale;
        }
    } else {
        for (size_t i = 0; i &lt; total_elements; i++) {
            planar_tensor[i] = (float)bsq_buffer[i] * scale;
        }
    }

    free(bsq_buffer);
    return planar_tensor;
}

// Versi√≥n simple sin opciones
float* load_image_bsq_u16_to_planar_f32(const char* filename, int B, int H, int W) {
    return load_image_bsq_u16_to_planar_f32_ex(filename, B, H, W, -1, 0);
}

/**
 * @brief Guarda un tensor planar (C x H x W) en un archivo .bin (float32).
 */
int save_tensor_planar_f32(const char* filename, const float* tensor, int C, int H, int W) {
    size_t total_elements = (size_t)C * H * W;
    FILE* f = fopen(filename, "wb");
    if (!f) {
        fprintf(stderr, "Error [IO]: No se pudo abrir el archivo de salida: %s\n", filename);
        return -1;
    }

    size_t elements_written = fwrite(tensor, sizeof(float), total_elements, f);
    fclose(f);

    if (elements_written != total_elements) {
        fprintf(stderr, "Error [IO]: Escritura incompleta en: %s\n", filename);
        return -1;
    }
    
    return 0;
}</code></pre>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>
